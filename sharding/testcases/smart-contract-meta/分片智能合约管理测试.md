# 分片智能合约管理测试

## 合约元数据初始化
合约中要提供合约MetaData初始化函数，该函数中调用Ontology底层提供的`InitMetaData`来实现MetaData的初始化。
对于已经部署到链上的合约,可以利用合约中提供的升级接口将合约升级到含有初始化MetaData的新合约。
```
def InitMetaData(owner, allShard, isfrozen, shardId, invokedContracts):
    """
    :param owner: address, contract owner
    :param allShard: bool, running multi shard or not
    :param isfrozen: bool, freeze contract or not
    :param shardId: integer, running shard id
    :param invokedContracts: address array, all contract can be x-shard call by self
    """
```
`owner` 合约所有者才可以调用

`allShard` 合约运行模式, true表示合约多分片运行模式, 否则是但分片运行模式

`isfrozen` 合约是否处于冻结状态,true表示合约处于冻结状态, false,表示合约处于非冻结状态,默认是false

`shardId` 必须是合约部署的当前的shard的Id或者是当前shard的子shard的Id。单分片模式下，当合约的状态已经被修改过了，即合约已经在ontology链上存储过数据时,`ShardId`只能是当前shard的Id。这种设计是为了支持合约的跨分片迁移，因为合约迁移只能在拥有同一个父分片的子分片之间进行，所以如果合约在当前分片运行了一段时间并且记录了数据之后，再将合约的元数据的`ShardId`初始化成当前shard的子shard的Id，则该合约将无法在分片之间进行迁移，因为合约已经产生的数据被存储在了当前分片上。另一方面，当合约的状态已经修改过了，该合约初始化元数据时，可以将该合约的运行模式设置成多分片的，即元数据的<code>AllShard</code>设为true。因为多分片模式运行的合约不需要支持合约间迁移，它只需要在一个父分片及所有子分片之间都能调用就行了。

`invokedContracts` 参数设置该合约可以跨分片调用的合约地址。

进行该部分测试之前 需要准备好如下的测试环境
1. RootShard-> Shard1

RootShard 是主链, Shard1和Shard2是RootShard的子Shard

2. 准备好合约A和合约B,

3. 将合约A和合约B部署到RootShard

### Case1 向shard上部署合约(不建议向shard上部署合约)
#### 步骤

1. 构造向shard1部署合约A交易
2. 发送交易，等待落账

#### 期望

部署成功

### Case2 测试allShard模式运行的合约
#### 步骤
合约A的allShard设置为true。
1. 构造合约A和合约B部署到RootShard的交易
2. 发送交易等待落账
3. 由于合约A要跨分片调用合约B,所以需要先初始化合约B的MetaData,
4. 调用合约A中Meta的初始化方法`init`,allShard设置为true, ShardId为0,invokedContracts设置为合约B的地址
5. 分别向RootShard,Shard1和Shard2上发调用合约A中的`hello`方法的交易,该交易是预执行交易，可以直接拿到结果


#### 期望
发往任一个分片的调用交易均成功

初始MetaData交易可以看到如下的推送事件
可以通过查询该交易的事件来看交易是否成功
```
{
   "TxHash": "c5d4816e33124adbd985ab9c9b08d67940425dff6c0306318bc0342d450eb5e7",
   "State": 1,
   "GasConsumed": 0,
   "Notify": [
      {
         "ContractAddress": "6a3250aebc05b3f9f50acaacb5326a9d9ee9fd07",
         "States": {
            "Height": 778,
            "MetaData": {
               "AllShard": true,
               "Contract": "AGW8YzjczMJzZuwK2sXWABkYMDAaSXfqks",
               "InvokedContract": [
                  "AUptUAxVvQbnCjevx4TXBPdtcB8g5cuoer"
               ],
               "IsFrozen": false,
               "OntVersion": 1,
               "Owner": "ALz86Xe1FR6oJ4xJW6PKfNLj88cMEPKDuV",
               "ShardId": 0
            },
            "Version": 1
         }
      }
   ]
}
```
### Case3 更新owner

#### 步骤
该步要构造MetaData交易更新合约的owner,只有合约的owner才有权限更新owner
1. 构造合约A的原来的Owner更新合约A的owner的交易
2. 发送交易等待落账
3. 构造非合约A的owner调用更新合约A的owner的交易
4. 发送交易等待落账

#### 期望
第一个交易成功
第二个交易失败
该交易会推出notify事件来表示是否调用成功
```json
{
   "TxHash": "0ea23990ae24bb0a3f0cad3e65bd3e7aa374848531ad3c69ce15c2249da6754a",
   "State": 1,
   "GasConsumed": 0,
   "Notify": [
      {
         "ContractAddress": "7e16b050509a8eb8d9481bca5f8241142449cef2",
         "States": {
            "Height": 733,
            "MetaData": {
               "AllShard": true,
               "Contract": "AduiHuMXSnekjM9KYtPkHpzra6HfMoUhq8",
               "InvokedContract": [
                  "AduiHuMXSnekjM9KYtPkHpzra6HfMoUhq8",
                  "AUptUAxVvQbnCjevx4TXBPdtcB8g5cuoer"
               ],
               "IsFrozen": true,
               "OntVersion": 1,
               "Owner": "AK9yDLXx2axjL3kzE2RFA1NgHPVUq5HMRP",
               "ShardId": 0
            },
            "Version": 1
         }
      }
   ]
}
```


### Case4 合约处于冻结状态，调用合约中的方法
#### 步骤
合约状态的变化可以通过构造MetaData交易来执行，只有合约owner才有权限更新合约状态
1. 更新合约A状态为冻结状态
2. 调用合约A中的方法

#### 期望
调用失败

### Case5 测试跨分片调用`invokedContracts`未配置的合约

跨分片调用只能调用该合约的`invokedContracts`配置的合约地址

#### 步骤

确保合约A已经进行MetaData初始化
1. 合约B部署到rootshard上
2. 发送初始化合约B的MetaData的交易，等待落账
3. 合约A中有方法调用合约B, 调用该方法
4. 发送交易，等待落账

#### 期望

调用失败

可以查询交易的status来看交易是否成功

### Case6 测试跨分片调用`invokedContracts`配置的合约

跨分片调用只能调用该合约的`invokedContracts`配置的合约地址。

#### 步骤

合约A已经进行MetaData初始化
1. 合约B部署到rootshard上
2. 更新合约A的MetaData配置，在合约A的`invokedContracts`中添加合约B的地址
3. 合约A中有方法调用合约B, 调用该方法
4. 发送交易，等待落账

#### 期望
调用成功


### Case7 测试one-shard模式运行的合约
#### 步骤
合约B的allShard设置为false
1. 调用合约B中Meta的初始化方法,allShard设置为false, ShardId为1,invokedContracts设置为ont和合约A的合约地址
2. 分别向RootShard,Shard1和Shard2上发调用合约A中的方法的交易

#### 期望
发往shard1的调用交易成功
发往shard2的调用交易失败
发往rootshard的调用交易失败

### Case8 合约处于锁定状态，调用合约升级
#### 步骤
1. 合约A同步调用合约B,使得合约A处于锁定状态
2. 调用合约A的升级方法,
3. 要确保在第一个交易落账之前，已发出调用合约A的升级方法，为了防止合约变为未锁定状态

#### 期望

调用失败


### Case9 跨分片调用合约(同步调用)
#### 步骤
1. 合约A中有调用合约B的方法`invokeContractB`, 调用合约A中的该方法.
2. 发送交易，等待落账
#### 期望
调用成功

### Case10 跨分片调用合约(异步调用)
#### 步骤
1. 合约A中有调用合约B的方法`notifyContractB`, 调用合约A中的该方法.
2. 发送交易，等待落账

#### 期望

调用成功
